"""Tests for write_source_files"""
# Inspired by https://github.com/cgrindel/bazel-starlib/blob/main/updatesrc/private/updatesrc_update_test.bzl

load("//lib:paths.bzl", "to_rlocation_path")
load("//lib:windows_utils.bzl", "BATCH_RLOCATION_FUNCTION")
load("//lib/private:directory_path.bzl", "DirectoryPathInfo")
load("//lib/private:write_source_file.bzl", _write_source_file = "write_source_file")

def _write_source_file_test_impl_sh(ctx, in_file_path, out_file_path):
    test = ctx.actions.declare_file(
        ctx.label.name + "_test.sh",
    )

    contents = []

    contents.append("""
#!/usr/bin/env bash
set -o errexit -o nounset -o pipefail

assert_different() {
  local in_file="${1}"
  local out_file="${2}"
  diff  "${in_file}" "${out_file}" > /dev/null && (echo >&2 "Expected files to differ. in: ${in_file}, out: ${out_file}" && return -1)
  return 0
}

assert_same() {
  local in_file="${1}"
  local out_file="${2}"
  diff  "${in_file}" "${out_file}" || (echo >&2 "Expected files to be same. in: ${in_file}, out: ${out_file}" && return -1)
}""")

    contents.append("""
# Check that in and out files are different
assert_different {in_file} {out_file}
""".format(
        in_file = in_file_path,
        out_file = out_file_path,
    ))

    contents.append("""# Write to the source files
{write_source_files}
""".format(write_source_files = ctx.file.write_source_file_target.short_path))

    contents.append("""# Check that in and out files are the same
assert_same {in_file} {out_file}""".format(
        in_file = in_file_path,
        out_file = out_file_path,
    ))

    ctx.actions.write(
        output = test,
        is_executable = True,
        content = "\n".join(contents),
    )

    return test

def _write_source_file_test_impl_bat(ctx, in_file, in_sub_path, out_path):
    test = ctx.actions.declare_file(
        ctx.label.name + "_test.bat",
    )

    contents = []
    contents.append("""
@rem @generated by @bazel_lib//:lib/tests/write_source_files:write_source_file_test.bzl
@echo off
SETLOCAL ENABLEEXTENSIONS
SETLOCAL ENABLEDELAYEDEXPANSION
set RUNFILES_MANIFEST_ONLY=1
{BATCH_RLOCATION_FUNCTION}
@rem Check that in and out files are different
call :rlocation {in_file} in_path
set in_path=!in_path:/=\\!
set in_sub_path={in_sub_path}
if "!in_sub_path!" neq "" (
  set in_path=!in_path!\\!in_sub_path!
)
set out_path={out_path}

call :assert_different !in_path! !out_path!
if %errorlevel% neq 0 exit /b 1
""".format(
        BATCH_RLOCATION_FUNCTION = BATCH_RLOCATION_FUNCTION,
        in_file = to_rlocation_path(ctx, in_file),
        in_sub_path = in_sub_path,
        out_path = out_path,
    ))

    contents.append("""
@rem Write to the source files
call :rlocation {write_source_files} write_source_files
set write_source_files=!write_source_files:/=\\!
echo call %write_source_files%
call %write_source_files%
if %errorlevel% neq 0 exit /b 1
""".format(write_source_files = to_rlocation_path(ctx, ctx.file.write_source_file_target)))

    contents.append("""
@rem Check that in and out files are the same
call :assert_same %in_path% %out_path%
if %errorlevel% neq 0 exit /b 1
exit /b 0

:assert_different
fc %~1 %~2 > nul
if %errorlevel% neq 0 exit /b 0
echo Error: %~1 and %~2 are not different
exit /b 1

:assert_same
fc %~1 %~2 > nul
if %errorlevel% equ 0 exit /b 0
echo Error: %~1 and %~2 are not the same
exit /b 1
""")

    ctx.actions.write(
        output = test,
        is_executable = True,
        content = "\n".join(contents),
    )

    return test

def _write_source_file_test_impl(ctx):
    is_windows = ctx.target_platform_has_constraint(ctx.attr._windows_constraint[platform_common.ConstraintValueInfo])

    in_sub_path = ""
    if DirectoryPathInfo in ctx.attr.in_file:
        in_file = ctx.attr.in_file[DirectoryPathInfo].directory
        in_file_path = "/".join([in_file.short_path, ctx.attr.in_file[DirectoryPathInfo].path])
        in_sub_path = ctx.attr.in_file[DirectoryPathInfo].path
    else:
        if len(ctx.files.in_file) != 1:
            fail("in_file must be a single file or a target that provides a DirectoryPathInfo")
        in_file = ctx.files.in_file[0]
        in_file_path = in_file.short_path

    if is_windows:
        test = _write_source_file_test_impl_bat(ctx, in_file, in_sub_path, ctx.file.out_file.short_path)
    else:
        test = _write_source_file_test_impl_sh(ctx, in_file_path, ctx.file.out_file.short_path)

    runfiles = ctx.runfiles(
        files = [ctx.executable.write_source_file_target, in_file, ctx.file.out_file],
    )
    runfiles = runfiles.merge(ctx.attr._runfiles.default_runfiles)

    return DefaultInfo(
        executable = test,
        runfiles = runfiles,
    )

_write_source_file_test = rule(
    implementation = _write_source_file_test_impl,
    attrs = {
        "write_source_file_target": attr.label(
            allow_single_file = True,
            executable = True,
            # Intentionally use the target platform since the target is always meant to be `bazel
            # run` on the host machine but we don't want to transition it to the host platform and
            # have the generated file rebuilt in a separate output tree. Target platform should
            # always be equal to the host platform when using `write_source_files`.
            cfg = "target",
            mandatory = True,
        ),
        "out_file": attr.label(
            allow_single_file = True,
            mandatory = True,
        ),
        "in_file": attr.label(
            allow_files = True,
            mandatory = True,
        ),
        "_runfiles": attr.label(default = "@bazel_tools//tools/bash/runfiles"),
        "_windows_constraint": attr.label(default = "@platforms//os:windows"),
    },
    test = True,
)

def write_source_file_test(name, in_file, out_file, check_that_out_file_exists = True, size = "small", **kwargs):
    """Stamp a write_source_files executable and a test to run against it"""

    _write_source_file(
        name = name + "_updater",
        in_file = in_file,
        out_file = out_file,
        diff_test = False,
        check_that_out_file_exists = check_that_out_file_exists,
    )

    # Note that for testing we update the source files in the sandbox,
    # not the actual source tree.
    _write_source_file_test(
        name = name,
        write_source_file_target = name + "_updater",
        in_file = in_file,
        out_file = out_file,
        size = size,
        **kwargs
    )
