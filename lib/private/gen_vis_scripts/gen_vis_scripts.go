// Code generator for vis-encoding support scripts.
package main

import (
	"fmt"
	"io"
	"log"
	"os"
	"strings"
	"unicode"
)

func main() {
	for _, arg := range os.Args[1:] {
		name, dest, ok := strings.Cut(arg, "=")
		if !ok {
			log.Fatal("invalid generation spec:", arg)
		}

		f, err := os.Create(dest)
		if err != nil {
			log.Fatal(err)
		}
		defer mustClose(f)

		switch name {
		case "vis_escape_ascii.bzl":
			writeEscapeASCIIBzl(f)
		case "vis_escape_nonascii.sed":
			writeEscapeNonASCIISed(f)
		default:
			log.Fatal("unknown generated content:", name)
		}
	}
}

func mustClose(f *os.File) {
	if err := f.Close(); err != nil {
		log.Fatal(err)
	}
}

const newline rune = '\n'

// Escape all characters identified by mtree(5) as requiring escaping. Plus whitespace.
func shouldEscape(b byte) bool {
	return b == '\\' || b > unicode.MaxASCII || unicode.IsSpace(rune(b)) || !unicode.IsPrint(rune(b))
}

func writeEscapeASCIIBzl(w io.Writer) {
	fmt.Fprintln(w, strings.TrimSpace(`
# Code generated by gen_vis_scripts. DO NOT EDIT.
"A translation table for vis-encoding the ASCII range for mtree."

load(":strings.bzl", "maketrans")

VIS_ESCAPE_ASCII = maketrans({
	`))

	for i := 0; i <= unicode.MaxASCII; i++ {
		b := byte(i)
		if shouldEscape(b) {
			fmt.Fprintf(w, `    %[1]d: r"\%03[1]o",%[2]c`, b, newline)
		}
	}
	fmt.Fprintln(w, "})")
}

func writeEscapeNonASCIISed(w io.Writer) {
	fmt.Fprintln(w, strings.TrimSpace(`
# Code generated by gen_vis_scripts. DO NOT EDIT.
# Replace non-ASCII bytes with their octal escape sequences.
# Escaping of ASCII is done in Starlark prior to writing content out.
	`))
	fmt.Fprintln(w, "")

	for i := 0x80; i <= 0xFF; i++ {
		fmt.Fprintf(w, `s/\x%02[1]x/\\%03[1]o/g%[2]c`, i, newline)
	}
}
